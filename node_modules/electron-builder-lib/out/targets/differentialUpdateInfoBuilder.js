"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createBlockmap = exports.BLOCK_MAP_FILE_SUFFIX = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = require("bluebird-lst");
}

let createBlockmap = exports.createBlockmap = (() => {
    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (file, target, packager, safeArtifactName) {
        const blockMapInfo = yield (0, (_appPackageBuilder || _load_appPackageBuilder()).createDifferentialFile)(file);
        const updateInfo = {
            size: blockMapInfo.size,
            sha512: blockMapInfo.sha512
        };
        yield (0, (_fsExtraP || _load_fsExtraP()).writeFile)(`${file}${BLOCK_MAP_FILE_SUFFIX}`, blockMapInfo.blockMapData);
        packager.info.dispatchArtifactCreated({
            file: `${file}${BLOCK_MAP_FILE_SUFFIX}`,
            fileContent: blockMapInfo.blockMapData,
            safeArtifactName: `${safeArtifactName}${BLOCK_MAP_FILE_SUFFIX}`,
            target,
            arch: null,
            packager,
            updateInfo
        });
        return updateInfo;
    });

    return function createBlockmap(_x, _x2, _x3, _x4) {
        return _ref.apply(this, arguments);
    };
})();
//# sourceMappingURL=differentialUpdateInfoBuilder.js.map


exports.createNsisWebDifferentialUpdateInfo = createNsisWebDifferentialUpdateInfo;
exports.configureDifferentialAwareArchiveOptions = configureDifferentialAwareArchiveOptions;

var _appPackageBuilder;

function _load_appPackageBuilder() {
    return _appPackageBuilder = require("app-package-builder");
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = require("fs-extra-p");
}

var _path = _interopRequireWildcard(require("path"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

const BLOCK_MAP_FILE_SUFFIX = exports.BLOCK_MAP_FILE_SUFFIX = ".blockmap";
function createNsisWebDifferentialUpdateInfo(artifactPath, packageFiles) {
    if (packageFiles == null) {
        return null;
    }
    const keys = Object.keys(packageFiles);
    if (keys.length <= 0) {
        return null;
    }
    const packages = {};
    for (const arch of keys) {
        const packageFileInfo = packageFiles[arch];
        packages[arch] = Object.assign({}, packageFileInfo, { path: _path.basename(packageFileInfo.path) });
    }
    return { packages };
}
function configureDifferentialAwareArchiveOptions(archiveOptions) {
    archiveOptions.solid = false;
    // our reader doesn't support compressed headers
    archiveOptions.isArchiveHeaderCompressed = false;
    /*
     * dict size 64 MB: Full: 33,744.88 KB, To download: 17,630.3 KB (52%)
     * dict size 16 MB: Full: 33,936.84 KB, To download: 16,175.9 KB (48%)
     * dict size  8 MB: Full: 34,187.59 KB, To download:  8,229.9 KB (24%)
     * dict size  4 MB: Full: 34,628.73 KB, To download: 3,782.97 KB (11%)
        as we can see, if file changed in one place, all block is invalidated (and update size approximately equals to dict size)
     */
    archiveOptions.dictSize = 4;
    // do not allow to change compression level to avoid different packages
    archiveOptions.compression = "normal";
    return archiveOptions;
}